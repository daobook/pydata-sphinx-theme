# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, PyData Community
# This file is distributed under the same license as the PyData Sphinx Theme
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PyData Sphinx Theme \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-03-12 15:12+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../docs/demo/example_pandas.rst:6
msgid "Pandas example - Indexing and selecting data"
msgstr ""

#: ../../docs/demo/example_pandas.rst:10
msgid ""
"This is an example page with excerpts from the pandas docs, for some "
"\"real world\" content. But including it here apart from the rest of the "
"pandas docs will mean that some of the links won't work, and not all code"
" examples are shown with their complete outputs."
msgstr ""

#: ../../docs/demo/example_pandas.rst:15
msgid "The axis labeling information in pandas objects serves many purposes:"
msgstr ""

#: ../../docs/demo/example_pandas.rst:17
msgid ""
"Identifies data (i.e. provides *metadata*) using known indicators, "
"important for analysis, visualization, and interactive console display."
msgstr ""

#: ../../docs/demo/example_pandas.rst:19
msgid "Enables automatic and explicit data alignment."
msgstr ""

#: ../../docs/demo/example_pandas.rst:20
msgid "Allows intuitive getting and setting of subsets of the data set."
msgstr ""

#: ../../docs/demo/example_pandas.rst:22
msgid ""
"In this section, we will focus on the final point: namely, how to slice, "
"dice, and generally get and set subsets of pandas objects. The primary "
"focus will be on Series and DataFrame as they have received more "
"development attention in this area."
msgstr ""

#: ../../docs/demo/example_pandas.rst:29
msgid ""
"The Python and NumPy indexing operators ``[]`` and attribute operator "
"``.`` provide quick and easy access to pandas data structures across a "
"wide range of use cases. This makes interactive work intuitive, as "
"there's little new to learn if you already know how to deal with Python "
"dictionaries and NumPy arrays. However, since the type of the data to be "
"accessed isn't known in advance, directly using standard operators has "
"some optimization limits. For production code, we recommended that you "
"take advantage of the optimized pandas data access methods exposed in "
"this chapter."
msgstr ""

#: ../../docs/demo/example_pandas.rst:40 ../../docs/demo/example_pandas.rst:350
#: ../../docs/demo/example_pandas.rst:506
msgid ""
"Whether a copy or a reference is returned for a setting operation, may "
"depend on the context. This is sometimes called ``chained assignment`` "
"and should be avoided. See :ref:`Returning a View versus Copy "
"<indexing.view_versus_copy>`."
msgstr ""

#: ../../docs/demo/example_pandas.rst:48
msgid "Different choices for indexing"
msgstr ""

#: ../../docs/demo/example_pandas.rst:50
msgid ""
"Object selection has had a number of user-requested additions in order to"
" support more explicit location based indexing. Pandas now supports three"
" types of multi-axis indexing."
msgstr ""

#: ../../docs/demo/example_pandas.rst:54
msgid ""
"``.loc`` is primarily label based, but may also be used with a boolean "
"array. ``.loc`` will raise ``KeyError`` when the items are not found. "
"Allowed inputs are:"
msgstr ""

#: ../../docs/demo/example_pandas.rst:56 ../../docs/demo/example_pandas.rst:384
msgid ""
"A single label, e.g. ``5`` or ``'a'`` (Note that ``5`` is interpreted as "
"a *label* of the index. This use is **not** an integer position along the"
" index.)."
msgstr ""

#: ../../docs/demo/example_pandas.rst:59 ../../docs/demo/example_pandas.rst:385
msgid "A list or array of labels ``['a', 'b', 'c']``."
msgstr ""

#: ../../docs/demo/example_pandas.rst:60
msgid ""
"A slice object with labels ``'a':'f'`` (Note that contrary to usual "
"python slices, **both** the start and the stop are included, when present"
" in the index!)"
msgstr ""

#: ../../docs/demo/example_pandas.rst:63
msgid "A boolean array"
msgstr ""

#: ../../docs/demo/example_pandas.rst:64 ../../docs/demo/example_pandas.rst:80
msgid ""
"A ``callable`` function with one argument (the calling Series or "
"DataFrame) and that returns valid output for indexing (one of the above)."
msgstr ""

#: ../../docs/demo/example_pandas.rst:67
msgid "See more at :ref:`Selection by Label <indexing.label>`."
msgstr ""

#: ../../docs/demo/example_pandas.rst:69
msgid ""
"``.iloc`` is primarily integer position based (from ``0`` to ``length-1``"
" of the axis), but may also be used with a boolean array.  ``.iloc`` will"
" raise ``IndexError`` if a requested indexer is out-of-bounds, except "
"*slice* indexers which allow out-of-bounds indexing.  (this conforms with"
" Python/NumPy *slice* semantics).  Allowed inputs are:"
msgstr ""

#: ../../docs/demo/example_pandas.rst:76 ../../docs/demo/example_pandas.rst:514
msgid "An integer e.g. ``5``."
msgstr ""

#: ../../docs/demo/example_pandas.rst:77 ../../docs/demo/example_pandas.rst:515
msgid "A list or array of integers ``[4, 3, 0]``."
msgstr ""

#: ../../docs/demo/example_pandas.rst:78 ../../docs/demo/example_pandas.rst:516
msgid "A slice object with ints ``1:7``."
msgstr ""

#: ../../docs/demo/example_pandas.rst:79 ../../docs/demo/example_pandas.rst:389
#: ../../docs/demo/example_pandas.rst:517
msgid "A boolean array."
msgstr ""

#: ../../docs/demo/example_pandas.rst:83
msgid ""
"``.loc``, ``.iloc``, and also ``[]`` indexing can accept a ``callable`` "
"as indexer. See more at :ref:`Selection By Callable <indexing.callable>`."
msgstr ""

#: ../../docs/demo/example_pandas.rst:85
msgid ""
"Getting values from an object with multi-axes selection uses the "
"following notation (using ``.loc`` as an example, but the following "
"applies to ``.iloc`` as well). Any of the axes accessors may be the null "
"slice ``:``. Axes left out of the specification are assumed to be ``:``, "
"e.g. ``p.loc['a']`` is equivalent to ``p.loc['a', :, :]``."
msgstr ""

#: ../../docs/demo/example_pandas.rst:1
msgid "Object Type"
msgstr ""

#: ../../docs/demo/example_pandas.rst:1
msgid "Indexers"
msgstr ""

#: ../../docs/demo/example_pandas.rst:1
msgid "Series"
msgstr ""

#: ../../docs/demo/example_pandas.rst:1
msgid "``s.loc[indexer]``"
msgstr ""

#: ../../docs/demo/example_pandas.rst:1
msgid "DataFrame"
msgstr ""

#: ../../docs/demo/example_pandas.rst:1
msgid "``df.loc[row_indexer,column_indexer]``"
msgstr ""

#: ../../docs/demo/example_pandas.rst:102
msgid "Basics"
msgstr ""

#: ../../docs/demo/example_pandas.rst:104
msgid ""
"As mentioned when introducing the data structures in the last section, "
"the primary function of indexing with ``[]`` (a.k.a. ``__getitem__`` for "
"those familiar with implementing class behavior in Python) is selecting "
"out lower-dimensional slices. The following table shows return type "
"values when indexing pandas objects with ``[]``:"
msgstr ""

#: ../../docs/demo/example_pandas.rst:1
msgid "Selection"
msgstr ""

#: ../../docs/demo/example_pandas.rst:1
msgid "Return Value Type"
msgstr ""

#: ../../docs/demo/example_pandas.rst:1
msgid "``series[label]``"
msgstr ""

#: ../../docs/demo/example_pandas.rst:1
msgid "scalar value"
msgstr ""

#: ../../docs/demo/example_pandas.rst:1
msgid "``frame[colname]``"
msgstr ""

#: ../../docs/demo/example_pandas.rst:1
msgid "``Series`` corresponding to colname"
msgstr ""

#: ../../docs/demo/example_pandas.rst:118
msgid ""
"Here we construct a simple time series data set to use for illustrating "
"the indexing functionality:"
msgstr ""

#: ../../docs/demo/example_pandas.rst:142
msgid ""
"None of the indexing functionality is time series specific unless "
"specifically stated."
msgstr ""

#: ../../docs/demo/example_pandas.rst:145
msgid "Thus, as per above, we have the most basic indexing using ``[]``:"
msgstr ""

#: ../../docs/demo/example_pandas.rst:155
msgid ""
"You can pass a list of columns to ``[]`` to select columns in that order."
" If a column is not contained in the DataFrame, an exception will be "
"raised. Multiple columns can also be set in this manner:"
msgstr ""

#: ../../docs/demo/example_pandas.rst:185
msgid ""
"You may find this useful for applying a transform (in-place) to a subset "
"of the columns."
msgstr ""

#: ../../docs/demo/example_pandas.rst:190
msgid ""
"pandas aligns all AXES when setting ``Series`` and ``DataFrame`` from "
"``.loc``, and ``.iloc``."
msgstr ""

#: ../../docs/demo/example_pandas.rst:192
msgid ""
"This will **not** modify ``df`` because the column alignment is before "
"value assignment."
msgstr ""

#: ../../docs/demo/example_pandas.rst:220
msgid "The correct way to swap column values is by using raw values:"
msgstr ""

#: ../../docs/demo/example_pandas.rst:239
msgid "Attribute access"
msgstr ""

#: ../../docs/demo/example_pandas.rst:247
msgid ""
"You may access an index on a ``Series`` or  column on a ``DataFrame`` "
"directly as an attribute:"
msgstr ""

#: ../../docs/demo/example_pandas.rst:298
msgid ""
"You can use this access only if the index element is a valid Python "
"identifier, e.g. ``s.1`` is not allowed. See `here for an explanation of "
"valid identifiers "
"<https://docs.python.org/3/reference/lexical_analysis.html#identifiers>`__."
msgstr ""

#: ../../docs/demo/example_pandas.rst:302
msgid ""
"The attribute will not be available if it conflicts with an existing "
"method name, e.g. ``s.min`` is not allowed, but ``s['min']`` is possible."
msgstr ""

#: ../../docs/demo/example_pandas.rst:304
msgid ""
"Similarly, the attribute will not be available if it conflicts with any "
"of the following list: ``index``, ``major_axis``, ``minor_axis``, "
"``items``."
msgstr ""

#: ../../docs/demo/example_pandas.rst:307
msgid ""
"In any of these cases, standard indexing will still work, e.g. "
"``s['1']``, ``s['min']``, and ``s['index']`` will access the "
"corresponding element or column."
msgstr ""

#: ../../docs/demo/example_pandas.rst:310
msgid ""
"If you are using the IPython environment, you may also use tab-completion"
" to see these accessible attributes."
msgstr ""

#: ../../docs/demo/example_pandas.rst:313
msgid "You can also assign a ``dict`` to a row of a ``DataFrame``:"
msgstr ""

#: ../../docs/demo/example_pandas.rst:328
msgid ""
"You can use attribute access to modify an existing element of a Series or"
" column of a DataFrame, but be careful; if you try to use attribute "
"access to create a new column, it creates a new attribute rather than a "
"new column. In 0.21.0 and later, this will raise a ``UserWarning``:"
msgstr ""

#: ../../docs/demo/example_pandas.rst:346
msgid "Selection by label"
msgstr ""

#: ../../docs/demo/example_pandas.rst:356
msgid ""
"``.loc`` is strict when you present slicers that are not compatible (or "
"convertible) with the index type. For example using integers in a "
"``DatetimeIndex``. These will raise a ``TypeError``."
msgstr ""

#: ../../docs/demo/example_pandas.rst:371
msgid ""
"String likes in slicing *can* be convertible to the type of the index and"
" lead to natural slicing."
msgstr ""

#: ../../docs/demo/example_pandas.rst:377
msgid ""
"pandas provides a suite of methods in order to have **purely label based "
"indexing**. This is a strict inclusion based protocol. Every label asked "
"for must be in the index, or a ``KeyError`` will be raised. When slicing,"
" both the start bound **AND** the stop bound are *included*, if present "
"in the index. Integers are valid labels, but they refer to the label "
"**and not the position**."
msgstr ""

#: ../../docs/demo/example_pandas.rst:382
msgid ""
"The ``.loc`` attribute is the primary access method. The following are "
"valid inputs:"
msgstr ""

#: ../../docs/demo/example_pandas.rst:386
msgid ""
"A slice object with labels ``'a':'f'`` (Note that contrary to usual "
"python slices, **both** the start and the stop are included, when present"
" in the index! See :ref:`Slicing with labels "
"<indexing.slicing_with_labels>`."
msgstr ""

#: ../../docs/demo/example_pandas.rst:390
#: ../../docs/demo/example_pandas.rst:518
msgid "A ``callable``, see :ref:`Selection By Callable <indexing.callable>`."
msgstr ""

#: ../../docs/demo/example_pandas.rst:415
#: ../../docs/demo/example_pandas.rst:541
msgid "Note that setting works as well:"
msgstr ""

#: ../../docs/demo/example_pandas.rst:430
#: ../../docs/demo/example_pandas.rst:548
msgid "With a DataFrame:"
msgstr ""

#: ../../docs/demo/example_pandas.rst:457
msgid "Slicing with labels"
msgstr ""

#: ../../docs/demo/example_pandas.rst:459
msgid ""
"When using ``.loc`` with slices, if both the start and the stop labels "
"are present in the index, then elements *located* between the two "
"(including them) are returned:"
msgstr ""

#: ../../docs/demo/example_pandas.rst:473
msgid ""
"If at least one of the two is absent, but the index is sorted, and can be"
" compared against start and stop labels, then slicing will still work as "
"expected, by selecting labels which *rank* between the two:"
msgstr ""

#: ../../docs/demo/example_pandas.rst:494
msgid ""
"However, if at least one of the two is absent *and* the index is not "
"sorted, an error will be raised (since doing otherwise would be "
"computationally expensive, as well as potentially ambiguous for mixed "
"type indexes). For instance, in the above example, ``s.loc[1:6]`` would "
"raise ``KeyError``."
msgstr ""

#: ../../docs/demo/example_pandas.rst:502
msgid "Selection by position"
msgstr ""

#: ../../docs/demo/example_pandas.rst:510
msgid ""
"Pandas provides a suite of methods in order to get **purely integer based"
" indexing**. The semantics follow closely Python and NumPy slicing. These"
" are ``0-based`` indexing. When slicing, the start bound is *included*, "
"while the upper bound is *excluded*. Trying to use a non-integer, even a "
"**valid** label will raise an ``IndexError``."
msgstr ""

#: ../../docs/demo/example_pandas.rst:512
msgid ""
"The ``.iloc`` attribute is the primary access method. The following are "
"valid inputs:"
msgstr ""

#: ../../docs/demo/example_pandas.rst:557
msgid "Select via integer slicing:"
msgstr ""

#: ../../docs/demo/example_pandas.rst:564
msgid "Select via integer list:"
msgstr ""

#: ../../docs/demo/example_pandas.rst:583
msgid ""
"For getting a cross section using an integer position (equiv to "
"``df.xs(1)``):"
msgstr ""

#: ../../docs/demo/example_pandas.rst:589
msgid "Out of range slice indexes are handled gracefully just as in Python/Numpy."
msgstr ""

#: ../../docs/demo/example_pandas.rst:603
msgid ""
"Note that using slices that go out of bounds can result in an empty axis "
"(e.g. an empty DataFrame being returned)."
msgstr ""

#: ../../docs/demo/example_pandas.rst:614
msgid ""
"A single indexer that is out of bounds will raise an ``IndexError``. A "
"list of indexers where any element is out of bounds will raise an "
"``IndexError``."
msgstr ""

#: ../../docs/demo/example_pandas.rst:629
msgid "Selection by callable"
msgstr ""

#: ../../docs/demo/example_pandas.rst:631
msgid ""
"``.loc``, ``.iloc``, and also ``[]`` indexing can accept a ``callable`` "
"as indexer. The ``callable`` must be a function with one argument (the "
"calling Series or DataFrame) that returns valid output for indexing."
msgstr ""

#: ../../docs/demo/example_pandas.rst:684
msgid "You can use callable indexing in ``Series``."
msgstr ""

#: ../../docs/demo/example_pandas.rst:690
msgid ""
"Using these methods / indexers, you can chain data selection operations "
"without using a temporary variable."
msgstr ""

#: ../../docs/demo/example_pandas.rst:701
msgid "Boolean indexing"
msgstr ""

#: ../../docs/demo/example_pandas.rst:705
msgid ""
"Another common operation is the use of boolean vectors to filter the "
"data. The operators are: ``|`` for ``or``, ``&`` for ``and``, and ``~`` "
"for ``not``. These **must** be grouped by using parentheses, since by "
"default Python will evaluate an expression such as ``df['A'] > 2 & "
"df['B'] < 3`` as ``df['A'] > (2 & df['B']) < 3``, while the desired "
"evaluation order is ``(df['A > 2) & (df['B'] < 3)``."
msgstr ""

#: ../../docs/demo/example_pandas.rst:712
msgid ""
"Using a boolean vector to index a Series works exactly as in a NumPy "
"ndarray:"
msgstr ""

#: ../../docs/demo/example_pandas.rst:749
msgid ""
"You may select rows from a DataFrame using a boolean vector the same "
"length as the DataFrame's index (for example, something derived from one "
"of the columns of the DataFrame):"
msgstr ""

#: ../../docs/demo/example_pandas.rst:757
msgid ""
"List comprehensions and the ``map`` method of Series can also be used to "
"produce more complex criteria:"
msgstr ""

#: ../../docs/demo/example_pandas.rst:777
msgid ""
"With the choice methods :ref:`Selection by Label <indexing.label>`, "
":ref:`Selection by Position <indexing.integer>` you may select along more"
" than one axis using boolean vectors combined with other indexing "
"expressions."
msgstr ""

#: ../../docs/demo/example_pandas.rst:786
msgid "The :meth:`~pandas.DataFrame.query` Method"
msgstr ""

#: ../../docs/demo/example_pandas.rst:788
msgid ""
":class:`~pandas.DataFrame` objects have a :meth:`~pandas.DataFrame.query`"
" method that allows selection using an expression."
msgstr ""

#: ../../docs/demo/example_pandas.rst:791
msgid ""
"You can get the value of the frame where column ``b`` has values between "
"the values of columns ``a`` and ``c``. For example:"
msgstr ""

#: ../../docs/demo/example_pandas.rst:806
msgid ""
"Do the same thing but fall back on a named index if there is no column "
"with the name ``a``."
msgstr ""

#: ../../docs/demo/example_pandas.rst:816
msgid ""
"If instead you don't want to or cannot name your index, you can use the "
"name ``index`` in your query expression:"
msgstr ""

#: ../../docs/demo/example_pandas.rst:827
msgid ""
"If the name of your index overlaps with a column name, the column name is"
" given precedence. For example,"
msgstr ""

#: ../../docs/demo/example_pandas.rst:836
msgid ""
"You can still use the index in a query expression by using the special "
"identifier 'index':"
msgstr ""

#: ../../docs/demo/example_pandas.rst:843
msgid ""
"If for some reason you have a column named ``index``, then you can refer "
"to the index as ``ilevel_0`` as well, but at this point you should "
"consider renaming your columns to something less ambiguous."
msgstr ""

#: ../../docs/demo/example_pandas.rst:849
msgid ":class:`~pandas.MultiIndex` :meth:`~pandas.DataFrame.query` Syntax"
msgstr ""

#: ../../docs/demo/example_pandas.rst:851
msgid ""
"You can also use the levels of a ``DataFrame`` with a "
":class:`~pandas.MultiIndex` as if they were columns in the frame:"
msgstr ""

#: ../../docs/demo/example_pandas.rst:867
msgid ""
"If the levels of the ``MultiIndex`` are unnamed, you can refer to them "
"using special names:"
msgstr ""

#: ../../docs/demo/example_pandas.rst:877
msgid ""
"The convention is ``ilevel_0``, which means \"index level 0\" for the 0th"
" level of the ``index``."
msgstr ""

#: ../../docs/demo/example_pandas.rst:882
msgid ":meth:`~pandas.DataFrame.query` Use Cases"
msgstr ""

#: ../../docs/demo/example_pandas.rst:884
msgid ""
"A use case for :meth:`~pandas.DataFrame.query` is when you have a "
"collection of :class:`~pandas.DataFrame` objects that have a subset of "
"column names (or index levels/names) in common. You can pass the same "
"query to both frames *without* having to specify which frame you're "
"interested in querying"
msgstr ""

#: ../../docs/demo/example_pandas.rst:899
msgid ":meth:`~pandas.DataFrame.query` Python versus pandas Syntax Comparison"
msgstr ""

#: ../../docs/demo/example_pandas.rst:901
msgid "Full numpy-like syntax:"
msgstr ""

#: ../../docs/demo/example_pandas.rst:910
msgid ""
"Slightly nicer by removing the parentheses (by binding making comparison "
"operators bind tighter than ``&`` and ``|``)."
msgstr ""

#: ../../docs/demo/example_pandas.rst:917
msgid "Use English instead of symbols:"
msgstr ""

#: ../../docs/demo/example_pandas.rst:923
msgid "Pretty close to how you might write it on paper:"
msgstr ""

#: ../../docs/demo/example_pandas.rst:930
msgid "The ``in`` and ``not in`` operators"
msgstr ""

#: ../../docs/demo/example_pandas.rst:932
msgid ""
":meth:`~pandas.DataFrame.query` also supports special use of Python's "
"``in`` and ``not in`` comparison operators, providing a succinct syntax "
"for calling the ``isin`` method of a ``Series`` or ``DataFrame``."
msgstr ""

#: ../../docs/demo/example_pandas.rst:954
msgid "You can combine this with other expressions for very succinct queries:"
msgstr ""

#: ../../docs/demo/example_pandas.rst:969
msgid ""
"Note that ``in`` and ``not in`` are evaluated in Python, since "
"``numexpr`` has no equivalent of this operation. However, **only the** "
"``in``/``not in`` **expression itself** is evaluated in vanilla Python. "
"For example, in the expression"
msgstr ""

#: ../../docs/demo/example_pandas.rst:978
msgid ""
"``(b + c + d)`` is evaluated by ``numexpr`` and *then* the ``in`` "
"operation is evaluated in plain Python. In general, any operations that "
"can be evaluated using ``numexpr`` will be."
msgstr ""

#: ../../docs/demo/example_pandas.rst:983
msgid "Special use of the ``==`` operator with ``list`` objects"
msgstr ""

#: ../../docs/demo/example_pandas.rst:985
msgid ""
"Comparing a ``list`` of values to a column using ``==``/``!=`` works "
"similarly to ``in``/``not in``."
msgstr ""

#: ../../docs/demo/example_pandas.rst:1010
msgid "Returning a view versus a copy"
msgstr ""

#: ../../docs/demo/example_pandas.rst:1012
msgid ""
"When setting values in a pandas object, care must be taken to avoid what "
"is called ``chained indexing``. Here is an example."
msgstr ""

#: ../../docs/demo/example_pandas.rst:1025
msgid "Compare these two access methods:"
msgstr ""

#: ../../docs/demo/example_pandas.rst:1035
msgid ""
"These both yield the same results, so which should you use? It is "
"instructive to understand the order of operations on these and why method"
" 2 (``.loc``) is much preferred over method 1 (chained ``[]``)."
msgstr ""

#: ../../docs/demo/example_pandas.rst:1038
msgid ""
"``dfmi['one']`` selects the first level of the columns and returns a "
"DataFrame that is singly-indexed. Then another Python operation "
"``dfmi_with_one['second']`` selects the series indexed by ``'second'``. "
"This is indicated by the variable ``dfmi_with_one`` because pandas sees "
"these operations as separate events. e.g. separate calls to "
"``__getitem__``, so it has to treat them as linear operations, they "
"happen one after another."
msgstr ""

#: ../../docs/demo/example_pandas.rst:1043
msgid ""
"Contrast this to ``df.loc[:,('one','second')]`` which passes a nested "
"tuple of ``(slice(None),('one','second'))`` to a single call to "
"``__getitem__``. This allows pandas to deal with this as a single entity."
" Furthermore this order of operations *can* be significantly faster, and "
"allows one to index *both* axes if so desired."
msgstr ""

#: ../../docs/demo/example_pandas.rst:1048
msgid "Why does assignment fail when using chained indexing?"
msgstr ""

#: ../../docs/demo/example_pandas.rst:1050
msgid ""
"The problem in the previous section is just a performance issue. What's "
"up with the ``SettingWithCopy`` warning? We don't **usually** throw "
"warnings around when you do something that might cost a few extra "
"milliseconds!"
msgstr ""

#: ../../docs/demo/example_pandas.rst:1054
msgid ""
"But it turns out that assigning to the product of chained indexing has "
"inherently unpredictable results. To see this, think about how the Python"
" interpreter executes this code:"
msgstr ""

#: ../../docs/demo/example_pandas.rst:1068
msgid "But this code is handled differently:"
msgstr ""

#: ../../docs/demo/example_pandas.rst:1076
msgid ""
"See that ``__getitem__`` in there? Outside of simple cases, it's very "
"hard to predict whether it will return a view or a copy (it depends on "
"the memory layout of the array, about which pandas makes no guarantees), "
"and therefore whether the ``__setitem__`` will modify ``dfmi`` or a "
"temporary object that gets thrown out immediately afterward. **That's** "
"what ``SettingWithCopy`` is warning you about!"
msgstr ""

#: ../../docs/demo/example_pandas.rst:1083
msgid ""
"You may be wondering whether we should be concerned about the ``loc`` "
"property in the first example. But ``dfmi.loc`` is guaranteed to be "
"``dfmi`` itself with modified indexing behavior, so "
"``dfmi.loc.__getitem__`` / ``dfmi.loc.__setitem__`` operate on ``dfmi`` "
"directly. Of course, ``dfmi.loc.__getitem__(idx)`` may be a view or a "
"copy of ``dfmi``."
msgstr ""

#: ../../docs/demo/example_pandas.rst:1089
msgid ""
"Sometimes a ``SettingWithCopy`` warning will arise at times when there's "
"no obvious chained indexing going on. **These** are the bugs that "
"``SettingWithCopy`` is designed to catch! Pandas is probably trying to "
"warn you that you've done this:"
msgstr ""

#: ../../docs/demo/example_pandas.rst:1103
msgid "Yikes!"
msgstr ""

#: ../../docs/demo/example_pandas.rst:1108
msgid "Evaluation order matters"
msgstr ""

#: ../../docs/demo/example_pandas.rst:1110
msgid ""
"When you use chained indexing, the order and type of the indexing "
"operation partially determine whether the result is a slice into the "
"original object, or a copy of the slice."
msgstr ""

#: ../../docs/demo/example_pandas.rst:1114
msgid ""
"Pandas has the ``SettingWithCopyWarning`` because assigning to a copy of "
"a slice is frequently not intentional, but a mistake caused by chained "
"indexing returning a copy where a slice was expected."
msgstr ""

#: ../../docs/demo/example_pandas.rst:1118
msgid ""
"If you would like pandas to be more or less trusting about assignment to "
"a chained indexing expression, you can set the option "
"``mode.chained_assignment`` to one of these values:"
msgstr ""

#: ../../docs/demo/example_pandas.rst:1122
msgid "``'warn'``, the default, means a ``SettingWithCopyWarning`` is printed."
msgstr ""

#: ../../docs/demo/example_pandas.rst:1123
msgid ""
"``'raise'`` means pandas will raise a ``SettingWithCopyException`` you "
"have to deal with."
msgstr ""

#: ../../docs/demo/example_pandas.rst:1125
msgid "``None`` will suppress the warnings entirely."
msgstr ""

#: ../../docs/demo/example_pandas.rst:1137
msgid "This however is operating on a copy and will not work."
msgstr ""

#: ../../docs/demo/example_pandas.rst:1149
msgid "A chained assignment can also crop up in setting in a mixed dtype frame."
msgstr ""

#: ../../docs/demo/example_pandas.rst:1153
msgid "These setting rules apply to all of ``.loc/.iloc``."
msgstr ""

#: ../../docs/demo/example_pandas.rst:1155
msgid "This is the correct access method:"
msgstr ""

#: ../../docs/demo/example_pandas.rst:1163
msgid ""
"This *can* work at times, but it is not guaranteed to, and therefore "
"should be avoided:"
msgstr ""

#: ../../docs/demo/example_pandas.rst:1171
msgid "This will **not** work at all, and so should be avoided:"
msgstr ""

#: ../../docs/demo/example_pandas.rst:1185
msgid ""
"The chained assignment warnings / exceptions are aiming to inform the "
"user of a possibly invalid assignment. There may be false positives; "
"situations where a chained assignment is inadvertently reported."
msgstr ""

#: ../../docs/demo/example_pandas.rst:1189
msgid ""
"An example of a long HTML page, as is comming in the pandas documentation"
" in pydata-sphinx-theme."
msgstr ""

